# Task Tracking System

A kanban-style task board built into Spacebot. Tasks are the structured, actionable layer on top of the existing `Todo` memory type. The cortex promotes todos into tasks when they're deemed actionable. Humans approve tasks before the agent executes them. Workers use subtasks as their execution plan.

## Concept

Today, when an agent captures something actionable, it saves a `Todo` memory — free-form text with no structure, no status tracking, no execution path. The todo is useful as a quick capture mechanism during conversation, but there's no system to organize, prioritize, or act on those todos.

The task tracking system introduces a two-tier model:

1. **Todos (existing)** — lightweight memory captures. The agent notices something actionable during conversation and saves it as a `Todo` memory in natural language. No structure required. This remains unchanged.

2. **Tasks (new)** — structured, trackable items on a kanban board. A task has a title, description, status, priority, subtasks, metadata, and a numeric reference (`#42`). Tasks live in their own SQLite table, not in the memory system.

The cortex bridges the two: a new cortex loop scans recent `Todo` memories, evaluates whether they're actionable, and promotes them to tasks. The human approves before execution begins.

## The Flow

```
User says something actionable in conversation
  → Branch saves a Todo memory (existing behavior)
    → Cortex evaluates the todo (new loop)
      → Cortex creates a Task in "pending_approval" state
        → Human reviews on kanban board or via natural language
          → Human approves: "pick up #42"
            → Channel delegates to a branch
              → Branch updates task state and spawns a worker
                → Worker uses subtasks as execution plan
                  → Task moves to "done" on completion
```

Tasks can also be created directly — by the human through the UI or natural language, or by the cortex when it identifies actionable patterns across channels.

## Data Model

### `tasks` Table

```sql
CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    agent_id TEXT NOT NULL,
    task_number INTEGER NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL DEFAULT 'backlog',
    priority TEXT NOT NULL DEFAULT 'medium',
    subtasks TEXT,                    -- JSON array of subtask objects
    metadata TEXT,                    -- JSON object for arbitrary key-value pairs
    source_memory_id TEXT,           -- FK to memories(id), nullable
    worker_id TEXT,                  -- FK to worker_runs(id), nullable (set when executing)
    created_by TEXT NOT NULL,        -- 'cortex', 'human', 'branch'
    approved_at TIMESTAMP,
    approved_by TEXT,                -- user identifier or null
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP,
    UNIQUE(agent_id, task_number)
);

CREATE INDEX idx_tasks_agent ON tasks(agent_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_number ON tasks(agent_id, task_number);
CREATE INDEX idx_tasks_source_memory ON tasks(source_memory_id);
```

### Task Status (Kanban Columns)

Four fixed columns:

| Status        | Description                                                         |
| ------------- | ------------------------------------------------------------------- |
| `backlog`     | Captured but not ready for work. Default for cortex-promoted tasks. |
| `ready`       | Approved and ready to be picked up. Human has signed off.           |
| `in_progress` | A worker is actively executing this task.                           |
| `done`        | Completed.                                                          |

Plus one special status:

| Status             | Description                                                                 |
| ------------------ | --------------------------------------------------------------------------- |
| `pending_approval` | Cortex-created task awaiting human sign-off. Shown distinctly on the board. |

### Task Priority

```
critical, high, medium, low
```

Default: `medium`.

### Subtasks

Stored as a JSON array in the `subtasks` column. Simple checklist items, one level deep.

```json
[
	{"title": "Research existing API endpoints", "completed": false},
	{"title": "Draft schema changes", "completed": false},
	{"title": "Implement migration", "completed": true},
	{"title": "Update API handlers", "completed": false}
]
```

Subtasks are generated by the cortex when promoting a todo (pre-computed execution plan), or by a worker as it decomposes its task. The human can also edit subtasks in the UI.

### Metadata

Stored as a JSON object in the `metadata` column. Arbitrary key-value pairs for linking to external resources.

```json
{
	"github_issue": "https://github.com/spacedriveapp/spacebot/issues/123",
	"github_pr": "https://github.com/spacedriveapp/spacebot/pull/456",
	"estimated_effort": "small",
	"worker_type": "opencode",
	"directory": "/Users/james/Projects/spacebot",
	"skill": "rust-dev",
	"notes": "Depends on the auth refactor landing first"
}
```

No enforced schema — the UI renders known keys with special formatting (e.g., GitHub links become clickable badges) and displays unknown keys as plain key-value pairs. But we should provide the LLM with known keys that are supported by the UI.

### Task Numbering

Per-agent, monotonically increasing. The next number is derived from `SELECT COALESCE(MAX(task_number), 0) + 1 FROM tasks WHERE agent_id = ?`. Tasks are referenced as `#1`, `#42`, etc. in natural language and in the UI.

## Cortex Integration

### Todo Promotion Loop

A new cortex loop that runs on a configurable interval (default: 15 minutes). It:

1. Queries recent `Todo` memories that haven't been promoted yet (no corresponding task with `source_memory_id` pointing to them)
2. For each unprocessed todo, evaluates whether it's actionable using an LLM call with the current bulletin as context
3. If actionable, creates a `Task` with:
   - `status: pending_approval`
   - `created_by: cortex`
   - `source_memory_id` pointing back to the original todo
   - A title extracted/refined from the todo content
   - A description with more context
   - Subtasks if the cortex can decompose the work
   - Metadata pre-filled where possible (e.g., `worker_type`, `directory`, `skill` inferred from context)
4. If not actionable, skips it (the todo remains as-is in the memory system)

The LLM call is cheap — it's a single evaluation per todo, not a multi-turn agent loop. The prompt receives the todo content, the current bulletin, and recent task titles (to avoid duplicates).

### Task Execution Paths

There are two distinct execution paths for `ready` tasks. Both use the same branch -> worker execution model.

1. **Human-driven path (active channel use)**
   - A human says "pick up #42" (or similar) in a channel or cortex chat
   - The user-facing process delegates to a branch
   - The branch validates that the task is in `ready`
   - The branch moves the task to `in_progress`
   - The branch spawns a worker with the task description as the prompt
   - The branch sets `worker_id` on the task
   - If subtasks exist, they're included in the worker's system prompt as an execution plan

2. **Cortex-driven path (system idle / background pickup)**
   - A cortex loop monitors `ready` tasks
   - When pickup conditions are met (for example: no active human-driven task execution), cortex starts execution
   - Cortex follows the same execution steps via a branch: validate `ready` -> set `in_progress` -> spawn worker -> set `worker_id`

3. As the worker executes, it can only update progress for its assigned task via `task_update`
4. When the worker completes, the task moves to `done` with `completed_at` set

### Bulletin Integration

The bulletin generation loop should include a new section querying active tasks:

```rust
BulletinSection {
    name: "Active Tasks",
    search_mode: SearchMode::Typed,
    // This would actually query the tasks table, not memories
}
```

This requires a small extension to the bulletin gathering — a direct SQLite query on the `tasks` table for non-done tasks, formatted into the bulletin sections alongside memory data.

## Agent Interaction

### New Tools

**`task_create`** — Available to branches. Creates a task directly.

```
Arguments:
  title: String (required)
  description: String (optional)
  priority: String (optional, default "medium")
  subtasks: Vec<String> (optional, list of subtask titles)
  metadata: JSON (optional)
  status: String (optional, default "backlog" for branch-created tasks; cortex promotion sets `pending_approval` programmatically)
```

**`task_update`** — Available to branches and workers.

```
Arguments:
  task_number: i32 (required, the #N reference)
  title: String (optional)
  description: String (optional)
  status: String (optional)
  priority: String (optional)
  subtasks: JSON (optional, full replacement of subtasks array)
  metadata: JSON (optional, merged with existing)
  complete_subtask: i32 (optional, index of subtask to mark complete)
```

**`task_list`** — Available to branches. Lists tasks with optional filters.

```
Arguments:
  status: String (optional, filter by status)
  limit: i32 (optional, default 20)
```

### Natural Language Commands

The user-facing prompts (channel and cortex chat) should be updated to recognize task-related intents and delegate them to a branch:

- "pick up #42" / "start #42" / "execute #42" → approve and begin execution
- "approve #42" → move from `pending_approval` to `ready`
- "what's on the board?" / "show tasks" → list active tasks
- "cancel #42" → cancel a task
- "#42 is done" → mark complete

These don't need special parsing — the LLM handles intent recognition naturally, delegates to a branch, and the branch calls the appropriate task tool. User-facing processes do not call task tools directly.

## API Endpoints

| Method   | Path                                | Description                                             |
| -------- | ----------------------------------- | ------------------------------------------------------- |
| `GET`    | `/api/agents/tasks`                 | List tasks (filterable by status, priority)             |
| `GET`    | `/api/agents/tasks/:number`         | Get single task by number                               |
| `POST`   | `/api/agents/tasks`                 | Create task                                             |
| `PUT`    | `/api/agents/tasks/:number`         | Update task (status, priority, subtasks, metadata)      |
| `DELETE` | `/api/agents/tasks/:number`         | Delete task                                             |
| `POST`   | `/api/agents/tasks/:number/approve` | Approve a pending task (moves to ready)                 |
| `POST`   | `/api/agents/tasks/:number/execute` | Trigger execution (moves to in_progress, spawns worker) |

## Interface

### Kanban Board Tab

New tab on the agent page: **Tasks** (between Memories and Workers in the tab order).

The board renders five columns: `pending_approval`, `backlog`, `ready`, `in_progress`, `done`. Tasks are cards that can be dragged between columns (with validation — can't drag to `in_progress` without a worker, can't skip `ready` from `pending_approval`).

Each task card shows:

- `#N` — task number, prominent
- Title
- Priority badge (color-coded)
- Subtask progress (e.g., "2/5")
- Source indicator — cortex icon if promoted from a todo, human icon if manually created
- Worker status — if in_progress, shows live worker status
- Metadata badges — GitHub issue/PR links rendered as small icons

Clicking a card opens a detail panel (slide-out or modal) with:

- Full description (markdown rendered)
- Subtask checklist (interactive — human can check/uncheck)
- Metadata key-value editor
- Activity timeline (status changes, who approved, worker events)
- Source memory link (if promoted from a todo)
- Approve / Execute / Cancel buttons as appropriate

### Pending Approval Section

Tasks in `pending_approval` should be visually distinct — a banner or highlighted section at the top of the board. These are the "inbox" that the human needs to review. Each pending task has:

- Approve button (moves to `ready`)
- Reject button (deletes the task, optionally with a reason that feeds back to the cortex)
- Edit button (modify before approving)

### Task Count Badge

The Tasks tab in the agent navigation should show a badge with the count of `pending_approval` tasks, drawing the human's attention.

## Phases

### Phase 1: Data Layer

- Migration for `tasks` table
- `TaskStore` with CRUD operations, number generation, status transitions
- Rust types: `Task`, `TaskStatus`, `TaskPriority`, `Subtask`
- Validation: status transition rules (can't go backwards except to `backlog`)

### Phase 2: API + Tools

- REST endpoints for task CRUD
- `task_create`, `task_update`, `task_list` tools
- Wire tools into branch and worker tool servers
- Update user-facing prompts to recognize task intents and delegate to branches

### Phase 3: Cortex + Execution Path

- Todo promotion loop (scan todos, evaluate, create tasks)
- Promotion prompt template (`cortex_task_promotion.md.j2`)
- Bulletin section for active tasks
- Task execution path (approve/execute intent → branch validates ready task and spawns worker with task context)
- Cortex ready-task pickup loop (idle/background execution using the same branch -> worker path)
- Wire `task_update` into worker tool server so workers can update subtask progress only for assigned tasks

### Phase 4: Interface

- Kanban board component with drag-and-drop
- Task detail panel
- Pending approval UX
- Task count badge on tab
- API client types and hooks (`useTasks`, `useTaskBoard`)

### Phase 5: Polish

- SSE events for task state changes (real-time board updates)
- Worker completion → auto-move task to `done`
- Cortex chat integration (same branch -> worker execution pattern as normal channels)
- Telegram/Discord natural language commands for task management

## Phase Ordering

```
Phase 1 (data)      — standalone
Phase 2 (API)       — depends on Phase 1
Phase 3 (cortex+exec) — depends on Phase 2
Phase 4 (interface) — depends on Phase 2, independent of Phase 3
Phase 5 (polish)    — depends on Phases 3 + 4
```

Phases 3 and 4 can run in parallel after Phase 2.

## Open Questions

**Todo memory type retention.** The current design keeps `Todo` as a memory type and adds tasks as a separate system. This means a todo captured in conversation lives in the memory graph (searchable, associated, decayable) while its promoted task lives in the tasks table. The `source_memory_id` FK connects them. If we later decide todos are redundant, we can drop the type and have branches create tasks directly from channel intent — but the two-tier model gives the cortex room to filter and enrich before things hit the board.

**Task archival.** Done tasks accumulate. Options: auto-archive after N days, move to a separate `archived` status, or just filter them out in the UI. Not urgent for v1.

**Multi-agent task references.** With per-agent numbering, `#42` is unambiguous within an agent. If a user manages multiple agents, they'd need to specify which agent. The current routing (messages go to a specific agent's channel) handles this naturally — `#42` in agent A's channel refers to agent A's task #42.

**Worker task awareness.** Workers currently have no memory tools. When a worker executes a task, it gets the task description and subtasks in its system prompt. The `task_update` tool is the only task-system tool a worker gets, and it should only allow updates to that worker's assigned task. If a worker needs related memories, that context should be pre-gathered by a branch and included in the task description or worker prompt.

**Rejection feedback.** When a human rejects a pending task, should that feedback be saved as a memory or a cortex event? Saving it as a memory helps the cortex learn what's not actionable. Saving it as a cortex event is simpler. Could do both.
